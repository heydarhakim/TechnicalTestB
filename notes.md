My primary design decision was to decouple the monolithic structure by isolating responsibilities into distinct layers: stores for data persistence, services for business logic, and api for routing. I encapsulated the storage logic (Qdrant vs. in-memory fallback) entirely within a DocumentStore class. This ensures the rest of the application remains agnostic to the underlying database, preventing conditional logic from polluting the retrieval workflow.

A significant trade-off involved handling document IDs. The original code generated IDs based on len(docs_memory), which caused ID collisions when Qdrant was active (since the memory list remained empty). I chose to implement a simple internal _doc_counter within the DocumentStore class. While this introduces statefulness to the class, it was the cleanest way to guarantee unique integer IDs across both storage backends without adding complex database lookup overhead, effectively fixing the bug while preserving the external API contract.

These changes improve maintainability by establishing clear separation of concerns and explicit dependencies. The embedding and RAG workflows are now standalone services, allowing future developers to swap out the embedding model or modify the retrieval graph without risking regressions in the API or storage layers. Additionally, this structure allows the DocumentStore and RagWorkflow to be instantiated and tested in isolation, significantly enhancing testability.
notes:i've tried it with postman for the API testing 